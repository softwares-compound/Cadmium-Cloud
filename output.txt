.
├── Cargo.lock
├── Cargo.toml
├── Dockerfile
├── README.md
├── dev.yml
├── docker-compose.yml
├── get_code.sh
├── haproxy.cfg
├── mongod.conf
├── nginx.conf
├── output.txt
├── src
│   ├── db
│   │   ├── mod.rs
│   │   └── pool.rs
│   ├── graphql
│   │   ├── mod.rs
│   │   ├── query.rs
│   │   └── schema.rs
│   ├── handlers
│   │   ├── application_handler.rs
│   │   ├── log_handler.rs
│   │   ├── mod.rs
│   │   ├── organization_handler.rs
│   │   └── websocket_handler.rs
│   ├── lib.rs
│   ├── logger.rs
│   ├── main.rs
│   ├── models
│   │   ├── application.rs
│   │   ├── log.rs
│   │   ├── mod.rs
│   │   └── organization.rs
│   ├── routes
│   │   ├── applications.rs
│   │   ├── health.rs
│   │   ├── logs.rs
│   │   ├── mod.rs
│   │   ├── organizations.rs
│   │   └── websocket.rs
│   ├── services
│   │   ├── log_service.rs
│   │   ├── mod.rs
│   │   └── websocket_queue.rs
│   └── websocket
│       ├── connection.rs
│       ├── mod.rs
│       └── server.rs
└── xcript.py

=== Content of ./Cargo.toml ===
[package]
name = "cadmium-cloud"
version = "0.1.0"
edition = "2021"

[dependencies]
futures-util = "0.3"
chrono = { version = "0.4", features = ["serde"] }
async-graphql = "5.0"
actix-cors = "0.6" 
async-graphql-actix-web = "5.0"
actix-web = "4"
actix = "0.13"
actix-web-actors = "4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
mongodb = { version = "2.0", features = ["tokio-runtime"] }
dotenv = "0.15"
log = "0.4"
env_logger = "0.10"
tokio = { version = "1", features = ["full"] }


=== Content of ./Dockerfile ===
# Build stage
FROM rust:1.75-slim AS builder

WORKDIR /app

# Copy only dependency files first to leverage Docker cache
COPY Cargo.toml Cargo.lock ./

# Build dependencies only
RUN mkdir src && \
    echo "fn main() {}" > src/main.rs && \
    cargo build --release && \
    rm -rf src

# Copy the actual source code
COPY src ./src

# Build the application
RUN cargo build --release && \
    strip target/release/cadmium-cloud # Reduce binary size by stripping debug symbols

# Runtime stage
FROM debian:stable-slim

# Install minimal runtime libraries
RUN apt-get update && \
    apt-get install -y --no-install-recommends libssl3 ca-certificates && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy only the compiled binary
COPY --from=builder /app/target/release/cadmium-cloud .

# Set environment variables for logging and optimizations
ENV RUST_LOG=info

# Expose the application port
EXPOSE 8080

# Run the binary
CMD ["./cadmium-cloud"]



=== Content of ./haproxy.cfg ===
global
    log stdout local0 debug
    maxconn 10000            # Allow more concurrent connections
    tune.ssl.default-dh-param 2048
    spread-checks 5          # Spread health checks over time
    nbproc 1                 # Single process for better performance with HTTP

defaults
    log     global
    mode    http
    option  httplog
    option  dontlognull
    option  http-server-close
    option  forwardfor except 127.0.0.1
    timeout connect 5000ms
    timeout client  50000ms
    timeout server  50000ms
    maxconn 8000            # Increase the maximum per-client connections

frontend http_front
    bind *:80
    default_backend cadmium_back
    maxconn 8000            # Cap frontend connections for stability

backend cadmium_back
    balance leastconn        # Distribute traffic based on least connections
    option httpchk HEAD /healthz HTTP/1.1\r\nHost:\ cadmium-cloud
    server cadmium-server cadmium-cloud:8080 check maxconn 2000
    http-reuse always        # Reuse HTTP connections for better performance



=== Content of ./get_code.sh ===
#!/bin/bash

# Define the output file
output_file="project_code.txt"

# Initialize the output file
echo "Project Code Listing" > "$output_file"
echo "====================" >> "$output_file"
echo "" >> "$output_file"

# Find all files excluding the 'target' directory
find . -type f ! -path "./target/*" \( -name "*.rs" -o -name "*.toml" \) | while read -r file; do
    echo "Processing $file"
    echo "File: $file" >> "$output_file"
    echo "--------------------" >> "$output_file"
    cat "$file" >> "$output_file"
    echo "" >> "$output_file"
    echo "" >> "$output_file"
done

echo "Code listing has been saved to $output_file"



=== Content of ./.dockerignore ===
target/
.git/
.gitignore
Dockerfile
.dockerignore
README.md


=== Content of ./.gitignore ===
# Generated by Cargo
# These directories contain compiled files and executables
/target/
**/target/

# If you have a custom build directory, uncomment and specify it
# /build/

# Remove Cargo.lock from gitignore if creating an executable; keep it for libraries
# More information: https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
# /Cargo.lock

# Backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# JetBrains IDEs (e.g., IntelliJ IDEA, CLion) project files
.idea/
*.iml

# Visual Studio Code settings
.vscode/

# macOS Finder metadata
.DS_Store

# Vim swap files
*.swp

# Log files
*.log

# Node.js dependencies (if applicable)
node_modules/

# Temporary files
*.tmp
*.temp

.env
test.tsxt

project_code.txt
benchmark_scripts/
xcript.py


=== Content of ./.env ===
MONGODB_URI=mongodb://localhost:27017
MONGODB_DB=cadmium_cloud_db


=== Content of ./dev.yml ===
version: "3.8"

services:
  cadmium-cloud:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: cadmium-cloud
    restart: always
    ports:
      - "8080:8080"
    environment:
      - RUST_LOG=info 
      - MONGODB_URI=mongodb://mongodb:27017/cadmium-cloud # Updated for local container MongoDB connection
      - MONGODB_DB=cadmium-cloud
    depends_on:
      mongodb:
        condition: service_healthy # Wait for MongoDB to be ready

  mongodb:
      image: mongo:latest
      container_name: mongodb
      restart: always
      ports:
        - "27017:27017"
      volumes:
        - ./mongod.conf:/etc/mongod.conf:ro
      command: ["mongod", "--config", "/etc/mongod.conf"]
      ulimits:
        nofile:
          soft: 64000
          hard: 64000
      deploy:
        resources:
          limits:
            cpus: '3'
            memory: 16G
          reservations:
            cpus: '2'
            memory: 12G
      healthcheck:
        test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
        interval: 10s
        timeout: 10s
        retries: 3




volumes:
  mongodb-data:
    driver: local



=== Content of ./mongod.conf ===
storage:
  wiredTiger:
    engineConfig:
      cacheSizeGB: 12  # 50% of system memory
      configString: "cache_max_wait_ms=0,eviction=(threads_max=20)" 
    collectionConfig:
      blockCompressor: zstd
    indexConfig:
      prefixCompression: true

net:
  port: 27017

setParameter:
  maxIndexBuildMemoryUsageMegabytes: 4096
  storageEngineConcurrentReadTransactions: 256
  storageEngineConcurrentWriteTransactions: 128
  enableFlowControl: false  # Maximum throughput

operationProfiling:
  slowOpThresholdMs: 200  # Quick threshold for slow queries


=== Content of ./docker-compose.yml ===
version: "3.8"

services:
  cadmium-cloud:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: cadmium-cloud
    restart: always
    ports:
      - "8080:8080"
    environment:
      - RUST_LOG=info 
      - MONGODB_URI=mongodb://mongodb:27017/cadmium-cloud # Updated for local container MongoDB connection
      - MONGODB_DB=cadmium-cloud
    depends_on:
      mongodb:
        condition: service_healthy # Wait for MongoDB to be ready

  mongodb:
      image: mongo:latest
      container_name: mongodb
      restart: always
      ports:
        - "27017:27017"
      volumes:
        - /mnt/block-volume:/data/db
        - ./mongod.conf:/etc/mongod.conf:ro
      command: ["mongod", "--config", "/etc/mongod.conf"]
      ulimits:
        nofile:
          soft: 64000
          hard: 64000
      deploy:
        resources:
          limits:
            cpus: '3'
            memory: 16G
          reservations:
            cpus: '2'
            memory: 12G
      healthcheck:
        test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
        interval: 10s
        timeout: 10s
        retries: 3

  nginx:
    image: nginx:latest
    container_name: nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - /var/www/certbot:/var/www/certbot
      - /etc/letsencrypt:/etc/letsencrypt:ro
    depends_on:
      cadmium-cloud:
        condition: service_started


volumes:
  mongodb-data:
    driver: local



=== Content of ./nginx.conf ===
worker_processes auto; # Automatically set the number of worker processes based on CPU cores
worker_rlimit_nofile 65535; # Increase file descriptor limit

events {
    worker_connections 20480; # Increase connections for high concurrency
    multi_accept on;          # Accept multiple connections at a time
}

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 75s;
    types_hash_max_size 4096;

    gzip on;
    gzip_types text/plain application/json text/css application/javascript application/xml text/xml;
    gzip_min_length 1024;
    gzip_comp_level 6;

    client_body_buffer_size 128k;
    client_header_buffer_size 64k;
    large_client_header_buffers 4 64k;
    client_max_body_size 10m;

    # Redirect HTTP traffic to HTTPS
    server {
        listen 80;
        server_name cadmium.softwarescompound.in;

        # Serve Certbot challenge files
        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
        }

        # Redirect other HTTP requests to HTTPS
        location / {
            return 301 https://$host$request_uri;
        }
    }

    # HTTPS server block
    server {
        listen 443 ssl http2;
        server_name cadmium.softwarescompound.in;

        # SSL certificate and key
        ssl_certificate /etc/letsencrypt/live/cadmium.softwarescompound.in/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/cadmium.softwarescompound.in/privkey.pem;

        # SSL protocols and ciphers
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Optional: Enable HSTS for better security
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

        # Proxy requests to the backend
        location / {
            proxy_pass http://cadmium-cloud:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket headers
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Timeout settings for WebSocket
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;

            proxy_connect_timeout 120s;

            proxy_buffering on;
            proxy_buffers 32 64k;
            proxy_buffer_size 128k;
            proxy_busy_buffers_size 256k;
            proxy_temp_file_write_size 256k;
        }
    }
}



=== Content of ./output.txt ===

=== Content of ./Cargo.toml ===
[package]
name = "cadmium-cloud"
version = "0.1.0"
edition = "2021"

[dependencies]
futures-util = "0.3"
chrono = { version = "0.4", features = ["serde"] }
async-graphql = "5.0"
actix-cors = "0.6" 
async-graphql-actix-web = "5.0"
actix-web = "4"
actix = "0.13"
actix-web-actors = "4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
mongodb = { version = "2.0", features = ["tokio-runtime"] }
dotenv = "0.15"
log = "0.4"
env_logger = "0.10"
tokio = { version = "1", features = ["full"] }



=== Content of ./Dockerfile ===
# Build stage
FROM rust:1.75-slim AS builder

WORKDIR /app

# Copy only dependency files first to leverage Docker cache
COPY Cargo.toml Cargo.lock ./

# Build dependencies only
RUN mkdir src && \
    echo "fn main() {}" > src/main.rs && \
    cargo build --release && \
    rm -rf src

# Copy the actual source code
COPY src ./src

# Build the application
RUN cargo build --release && \
    strip target/release/cadmium-cloud # Reduce binary size by stripping debug symbols

# Runtime stage
FROM debian:stable-slim

# Install minimal runtime libraries
RUN apt-get update && \
    apt-get install -y --no-install-recommends libssl3 ca-certificates && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy only the compiled binary
COPY --from=builder /app/target/release/cadmium-cloud .

# Set environment variables for logging and optimizations
ENV RUST_LOG=info

# Expose the application port
EXPOSE 8080

# Run the binary
CMD ["./cadmium-cloud"]



=== Content of ./haproxy.cfg ===
global
    log stdout local0 debug
    maxconn 10000            # Allow more concurrent connections
    tune.ssl.default-dh-param 2048
    spread-checks 5          # Spread health checks over time
    nbproc 1                 # Single process for better performance with HTTP

defaults
    log     global
    mode    http
    option  httplog
    option  dontlognull
    option  http-server-close
    option  forwardfor except 127.0.0.1
    timeout connect 5000ms
    timeout client  50000ms
    timeout server  50000ms
    maxconn 8000            # Increase the maximum per-client connections

frontend http_front
    bind *:80
    default_backend cadmium_back
    maxconn 8000            # Cap frontend connections for stability

backend cadmium_back
    balance leastconn        # Distribute traffic based on least connections
    option httpchk HEAD /healthz HTTP/1.1\r\nHost:\ cadmium-cloud
    server cadmium-server cadmium-cloud:8080 check maxconn 2000
    http-reuse always        # Reuse HTTP connections for better performance



=== Content of ./get_code.sh ===
#!/bin/bash

# Define the output file
output_file="project_code.txt"

# Initialize the output file
echo "Project Code Listing" > "$output_file"
echo "====================" >> "$output_file"
echo "" >> "$output_file"

# Find all files excluding the 'target' directory
find . -type f ! -path "./target/*" \( -name "*.rs" -o -name "*.toml" \) | while read -r file; do
    echo "Processing $file"
    echo "File: $file" >> "$output_file"
    echo "--------------------" >> "$output_file"
    cat "$file" >> "$output_file"
    echo "" >> "$output_file"
    echo "" >> "$output_file"
done

echo "Code listing has been saved to $output_file"



=== Content of ./README.md ===
# Cadmium Cloud

Cadmium Cloud is a Rust-based web application designed to manage organizations and applications, handle log data, and facilitate real-time communication through WebSocket connections.

## Features

- **Organization and Application Management**: Create and manage organizations and their associated applications.
- **Log Handling**: Receive and store log data with support for retry mechanisms.
- **WebSocket Communication**: Establish WebSocket connections for real-time data transmission.

## Project Structure

The project is organized as follows:

```
.
├── Cargo.lock
├── Cargo.toml
├── Dockerfile
├── README.md
├── src
│   ├── db
│   │   ├── mod.rs
│   │   └── pool.rs
│   ├── handlers
│   │   ├── application_handler.rs
│   │   ├── log_handler.rs
│   │   ├── mod.rs
│   │   ├── organization_handler.rs
│   │   └── websocket_handler.rs
│   ├── lib.rs
│   ├── logger.rs
│   ├── main.rs
│   ├── models
│   │   ├── application.rs
│   │   ├── log.rs
│   │   ├── mod.rs
│   │   └── organization.rs
│   ├── routes
│   │   ├── applications.rs
│   │   ├── health.rs
│   │   ├── logs.rs
│   │   ├── mod.rs
│   │   ├── organizations.rs
│   │   └── websocket.rs
│   ├── services
│   │   ├── log_service.rs
│   │   ├── mod.rs
│   │   └── websocket_queue.rs
│   └── websocket
│       ├── connection.rs
│       ├── mod.rs
│       └── server.rs
└── test.txt
```

## Getting Started

### Prerequisites

- [Rust](https://www.rust-lang.org/tools/install)
- [MongoDB](https://www.mongodb.com/try/download/community)

### Installation

1. **Clone the repository**:

   ```bash
   git clone https://github.com/yourusername/cadmium-cloud.git
   cd cadmium-cloud
   ```

2. **Set up environment variables**:

   Create a `.env` file in the root directory with the following content:

   ```
   MONGODB_URI=mongodb://localhost:27017
   MONGODB_DB=cadmium_cloud_db
   ```

   Adjust the values as needed.

3. **Build and run the application**:

   ```bash
   cargo build --release
   ./target/release/cadmium-cloud
   ```

The server will start on `http://0.0.0.0:8080`.

## Usage

### API Endpoints

- **Health Check**:

  ```
  GET /health
  ```

  Response:

  ```json
  {
    "status": "healthy"
  }
  ```

- **Organizations**:

  - Create an organization:

    ```
    POST /organizations
    ```

    Request body:

    ```json
    {
      "org_name": "Your Organization Name",
      "admin_email": "admin@example.com",
      "admin_password": "yourpassword",
      "cd_id": "your_cd_id",
      "cd_secret": "your_cd_secret"
    }
    ```

    Response:

    ```json
    {
      "message": "Organization created"
    }
    ```

- **Applications**:

  - Create an application:

    ```
    POST /applications
    ```

    Request body:

    ```json
    {
      "organization_id": "organization_object_id",
      "application_name": "Your Application Name"
    }
    ```

    Response:

    ```json
    {
      "message": "Application created"
    }
    ```

- **Logs**:

  - Save a log:

    ```
    POST /logs
    ```

    Headers:

    ```
    CD-ID: your_cd_id
    CD-Secret: your_cd_secret
    Application-ID: application_object_id
    ```

    Request body:

    ```json
    {
      "error": "Error message",
      "traceback": "Traceback details",
      "url": "URL where error occurred",
      "method": "HTTP method"
    }
    ```

    Response:

    ```json
    {
      "message": "Log saved"
    }
    ```

- **WebSocket**:

  - Establish a WebSocket connection:

    ```
    GET /ws
    ```

    Headers:

    ```
    CD-ID: your_cd_id
    CD-Secret: your_cd_secret
    Application-ID: application_object_id
    ```

    Upon successful connection, the server will send real-time updates.

## Contributing

Contributions are welcome! Please fork the repository and submit a pull request.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details. 


=== Content of ./.dockerignore ===
target/
.git/
.gitignore
Dockerfile
.dockerignore
README.md


=== Content of ./.gitignore ===



=== Content of ./src/logger.rs ===
use env_logger;

pub fn init() {
    env_logger::init();
}



=== Content of ./src/lib.rs ===
pub mod db;
pub mod handlers;
pub mod logger;
pub mod models;
pub mod routes;
pub mod services;
pub mod websocket;
pub mod graphql;


=== Content of ./src/main.rs ===
use actix_web::{middleware, web, App, HttpServer, HttpRequest};
use async_graphql_actix_web::{GraphQLRequest, GraphQLResponse};
use dotenv::dotenv;
use actix_cors::Cors; // Import Cors middleware
mod db;
mod handlers;
mod logger;
mod models;
mod routes;
mod services;
mod websocket;
mod graphql;  // Make sure this module is declared

use crate::graphql::schema::{create_schema, AppSchema};
use crate::websocket::server::WebSocketServer;
use crate::services::websocket_queue::WebSocketQueue;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenv().ok();
    logger::init();

    let mongo_repo = db::MongoRepo::init().await;

    // Initialize the WebSocket server and queue
    let websocket_server = WebSocketServer::new();
    let websocket_queue = WebSocketQueue::new();

    let websocket_server_data = web::Data::new(websocket_server.clone());
    let websocket_queue_data = web::Data::new(websocket_queue.clone());
    
    // Create GraphQL schema
    let schema = create_schema(mongo_repo.clone());
    let schema_data = web::Data::new(schema);

    let server = HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(mongo_repo.clone()))
            .app_data(schema_data.clone())
            .app_data(websocket_server_data.clone())
            .app_data(websocket_queue_data.clone())
            .wrap(middleware::Logger::default())
            .wrap(
                Cors::default() // Configure CORS to allow all origins
                    .allow_any_origin() // Allow any origin (bypass CORS)
                    .allow_any_method() // Allow any HTTP method
                    .allow_any_header() // Allow any header
            )
            .configure(routes::init)
            .route("/graphql", web::post().to(graphql_handler))
    })
    .bind(("0.0.0.0", 8080))?;

    let server_result = server.run().await;

    // Optionally handle the queue processor task if needed
    // queue_processor.await.expect("Queue processor task failed");

    server_result
}

async fn graphql_handler(
    schema: web::Data<AppSchema>,
    req: GraphQLRequest,
    http_req: HttpRequest,
) -> GraphQLResponse {
    let mut headers_map = std::collections::HashMap::new();

    // Extract headers
    if let Some(cd_id) = http_req.headers().get("CD-ID").and_then(|v| v.to_str().ok()) {
        headers_map.insert("CD-ID".to_string(), cd_id.to_string());
    }
    if let Some(cd_secret) = http_req.headers().get("CD-Secret").and_then(|v| v.to_str().ok()) {
        headers_map.insert("CD-Secret".to_string(), cd_secret.to_string());
    }
    if let Some(app_id) = http_req.headers().get("Application-ID").and_then(|v| v.to_str().ok()) {
        headers_map.insert("Application-ID".to_string(), app_id.to_string());
    }

    let mut request = req.into_inner();
    request = request.data(headers_map);

    schema.execute(request).await.into()
}


=== Content of ./src/websocket/server.rs ===
use crate::websocket::connection::WebSocketActor;
use actix::Addr;
use mongodb::bson::oid::ObjectId;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

/// Represents the global state of WebSocket connections.
#[derive(Clone)]
pub struct WebSocketServer {
    connections: Arc<RwLock<HashMap<String, Vec<Addr<WebSocketActor>>>>>,
}

impl WebSocketServer {
    /// Creates a new WebSocketServer instance.
    pub fn new() -> Self {
        Self {
            connections: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Adds a WebSocket connection for a specific organization and application.
    pub async fn add_connection(&self, org_id: ObjectId, conn: Addr<WebSocketActor>) {
        let org_id_str = org_id.to_string();
        let mut connections = self.connections.write().await;
        connections.entry(org_id_str).or_default().push(conn);
    
        log::info!("WebSocket connection added for Org ID: {}", org_id);
    }
    
    /// Removes a WebSocket connection for a specific organization and application.
    pub async fn remove_connection(&self, org_id: ObjectId, conn: Addr<WebSocketActor>) {
        let org_id_str = org_id.to_string();
        let mut connections = self.connections.write().await;
        if let Some(conn_list) = connections.get_mut(&org_id_str) {
            conn_list.retain(|c| c != &conn);
            log::info!("WebSocket connection removed for Org ID: {}", org_id);
        }
    }
    

    /// Gets one WebSocket connection for a specific organization and application.
    pub async fn get_connection(&self, org_id: ObjectId) -> Option<Addr<WebSocketActor>> {
        let org_id_str = org_id.to_string();
    
        let connections = self.connections.read().await;
        connections
            .get(&org_id_str)
            .and_then(|conn_list| conn_list.get(0).cloned())
    }
    

    /// Pushes a log ID to one connection for a specific organization and application.
    pub async fn push_log_id(&self, org_id: ObjectId, app_id: ObjectId, log_id: ObjectId) -> bool {
        let org_id_str = org_id.to_string();
        let connections = self.connections.read().await;
    
        if let Some(conn_list) = connections.get(&org_id_str) {
            for conn in conn_list {
                log::info!(
                    "Pushing log ID: {} to WebSocket connection for Org ID: {} and App ID: {}",
                    log_id, org_id,app_id
                );
                conn.do_send(crate::websocket::connection::SendLogId { log_id ,app_id});
            }
            return true;
        }
    
        log::warn!("No WebSocket connection found for Org ID: {}", org_id);
        false
    }
    
}


=== Content of ./src/websocket/mod.rs ===
pub mod connection;
pub mod server;



=== Content of ./src/websocket/connection.rs ===
use actix::{Actor, Handler,ActorContext, Message};
use actix_web_actors::ws;
use mongodb::bson::oid::ObjectId;
use actix::StreamHandler;
use actix::AsyncContext;

#[derive(Message)]
#[rtype(result = "()")]
pub struct SendLogId {
    pub log_id: ObjectId,
    pub app_id: ObjectId,
}

/// Represents a WebSocket connection.
pub struct WebSocketActor {
    pub organization_id: ObjectId,
}

impl WebSocketActor {
    pub fn new(organization_id: ObjectId) -> Self {
        Self { organization_id }
    }
}


impl Actor for WebSocketActor {
    type Context = ws::WebsocketContext<Self>;
}

impl Handler<SendLogId> for WebSocketActor {
    type Result = ();

    fn handle(&mut self, msg: SendLogId, ctx: &mut Self::Context) {
        let message = format!("New log ID: {} and App ID: {}", msg.log_id,msg.app_id);
        ctx.text(message);
    }
}




impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketActor {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
            Ok(ws::Message::Pong(_)) => (),
            Ok(ws::Message::Text(text)) => {
                log::info!("Received message: {}", text);
            }
            Ok(ws::Message::Close(reason)) => {
                log::info!("WebSocket connection closing: {:?}", reason);

                // Get the current actor's address
                let conn = ctx.address();
                let org_id = self.organization_id.clone();

                // Call remove_connection asynchronously
                let websocket_server = crate::websocket::server::WebSocketServer::new(); 
                actix::spawn(async move {
                    websocket_server.remove_connection(org_id, conn).await;
                });

                ctx.stop();
            }
            _ => ctx.stop(),
        }
    }
}



=== Content of ./src/models/organization.rs ===
use mongodb::bson::oid::ObjectId;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Organization {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub org_name: String,
    pub admin_email: String,
    pub admin_password: String,
    pub cd_id: String,
    pub cd_secret: String,
}



=== Content of ./src/models/log.rs ===
use async_graphql::*;
use chrono::{DateTime, Utc};
use mongodb::bson::oid::ObjectId;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogPayload {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub organization_id: Option<ObjectId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_id: Option<ObjectId>,
    pub error: String,
    pub traceback: String,
    pub url: String,
    pub method: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rag_inference: Option<serde_json::Value>, // Optional and can accept any structure
}

#[derive(SimpleObject)]
pub struct LogPayloadGql {
    pub id: Option<String>,
    pub organization_id: Option<String>,
    pub application_id: Option<String>,
    pub error: String,
    pub traceback: String,
    pub url: String,
    pub method: String,
    pub created_at: Option<String>,
    pub updated_at: Option<String>,
    pub rag_inference: Option<String>, // Represent as a JSON string in GraphQL
}

impl From<LogPayload> for LogPayloadGql {
    fn from(log: LogPayload) -> Self {
        Self {
            id: log.id.map(|id| id.to_string()),
            organization_id: log.organization_id.map(|id| id.to_string()),
            application_id: log.application_id.map(|id| id.to_string()),
            error: log.error,
            traceback: log.traceback,
            url: log.url,
            method: log.method,
            created_at: log.created_at.map(|dt| dt.to_rfc3339()),
            updated_at: log.updated_at.map(|dt| dt.to_rfc3339()),
            rag_inference: log.rag_inference.map(|v| v.to_string()), // Serialize the JSON to a string
        }
    }
}



=== Content of ./src/models/mod.rs ===
pub mod application;
pub mod log;
pub mod organization;




=== Content of ./src/models/application.rs ===
use mongodb::bson::oid::ObjectId;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Application {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    #[serde(skip_serializing_if = "Option::is_none")] // Allows omission during deserialization
    pub organization_id: Option<ObjectId>,
    pub application_name: String,
}

#[derive(Deserialize)]
pub struct DeleteApplicationPayload {
    pub application_id: String,
}



=== Content of ./src/graphql/query.rs ===
use async_graphql::{Context, Object, Result, Error};
use mongodb::bson::{doc, oid::ObjectId};
use mongodb::options::FindOptions;
use futures_util::stream::TryStreamExt;
use crate::db::MongoRepo;
use crate::models::log::{LogPayload, LogPayloadGql};

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    /// Fetches logs for a specific application based on headers and pagination parameters.
    async fn logs(
        &self,
        ctx: &Context<'_>,
        page: Option<i32>,
        limit: Option<i32>,
    ) -> Result<Vec<LogPayloadGql>> {
        let headers = ctx.data::<std::collections::HashMap<String, String>>()?;
        let cd_id = headers.get("CD-ID").ok_or_else(|| Error::new("Missing CD-ID"))?;
        let cd_secret = headers
            .get("CD-Secret")
            .ok_or_else(|| Error::new("Missing CD-Secret"))?;
        let app_id = headers
            .get("Application-ID")
            .ok_or_else(|| Error::new("Missing Application-ID"))?;

        let mongo_repo = ctx.data::<MongoRepo>()?;

        // Authenticate organization
        let org = mongo_repo
            .get_organization_by_cd_id_and_secret(cd_id, cd_secret)
            .await?
            .ok_or_else(|| Error::new("Invalid CD-ID or CD-Secret"))?;

        // Validate application
        let app_id = ObjectId::parse_str(app_id)
            .map_err(|_| Error::new("Invalid Application-ID format"))?;
        let app = mongo_repo
            .get_application_by_id(app_id)
            .await?
            .ok_or_else(|| Error::new("Application not found"))?;

        if app.organization_id != Some(org.id.unwrap()) {
            return Err(Error::new("Unauthorized"));
        }

        // Pagination logic
        let page = page.unwrap_or(1);
        let limit = limit.unwrap_or(10);
        let skip = (page - 1) * limit;

        // Fetch logs
        let collection = mongo_repo.db.collection::<LogPayload>("logs");
        let filter = doc! { "application_id": app.id.unwrap() };
        let find_options = FindOptions::builder()
            .skip(Some(skip as u64))
            .limit(Some(limit as i64))
            .sort(doc! { "created_at": -1 })
            .build();

        let mut cursor = collection.find(filter, find_options).await?;
        let mut logs = Vec::new();
        while let Some(log) = cursor.try_next().await? {
            logs.push(LogPayloadGql::from(log));
        }

        Ok(logs)
    }

    /// Fetches a single log by its ID.
    async fn log_by_id(
        &self,
        ctx: &Context<'_>,
        log_id: String,
    ) -> Result<LogPayloadGql> {
        let headers = ctx.data::<std::collections::HashMap<String, String>>()?;
        let cd_id = headers.get("CD-ID").ok_or_else(|| Error::new("Missing CD-ID"))?;
        let cd_secret = headers
            .get("CD-Secret")
            .ok_or_else(|| Error::new("Missing CD-Secret"))?;
        let app_id = headers
            .get("Application-ID")
            .ok_or_else(|| Error::new("Missing Application-ID"))?;

        let mongo_repo = ctx.data::<MongoRepo>()?;

        // Authenticate organization
        let org = mongo_repo
            .get_organization_by_cd_id_and_secret(cd_id, cd_secret)
            .await?
            .ok_or_else(|| Error::new("Invalid CD-ID or CD-Secret"))?;

        // Validate application
        let app_id = ObjectId::parse_str(app_id)
            .map_err(|_| Error::new("Invalid Application-ID format"))?;
        let app = mongo_repo
            .get_application_by_id(app_id)
            .await?
            .ok_or_else(|| Error::new("Application not found"))?;

        if app.organization_id != Some(org.id.unwrap()) {
            return Err(Error::new("Unauthorized"));
        }

        // Fetch the log
        let log_id = ObjectId::parse_str(&log_id)
            .map_err(|_| Error::new("Invalid Log ID format"))?;
        let collection = mongo_repo.db.collection::<LogPayload>("logs");
        let filter = doc! { "_id": log_id, "application_id": app.id.unwrap() };

        let log = collection
            .find_one(filter, None)
            .await?
            .ok_or_else(|| Error::new("Log not found"))?;

        Ok(LogPayloadGql::from(log))
    }
}



=== Content of ./src/graphql/mod.rs ===
pub mod schema;
pub mod query;



=== Content of ./src/graphql/schema.rs ===
use async_graphql::{Schema, EmptyMutation, EmptySubscription};
use crate::graphql::query::QueryRoot;
use crate::db::MongoRepo;

pub type AppSchema = Schema<QueryRoot, EmptyMutation, EmptySubscription>;

pub fn create_schema(mongo_repo: MongoRepo) -> AppSchema {
    Schema::build(QueryRoot, EmptyMutation, EmptySubscription)
        .data(mongo_repo) // Share the MongoRepo instance
        .finish()
}



=== Content of ./src/db/mod.rs ===
use crate::models::{application::Application, organization::Organization};
use mongodb::{
    bson::{doc, oid::ObjectId},
    options::{ClientOptions, ServerApi, ServerApiVersion},
    Client, Database,
};
use std::env;

#[derive(Clone)]
pub struct MongoRepo {
    pub db: Database,
}

impl MongoRepo {
    pub async fn init() -> Self {
        let uri = env::var("MONGODB_URI").expect("MONGODB_URI must be set");
        let mut client_options = ClientOptions::parse(&uri)
            .await
            .expect("Failed to parse client options");

        // Set the server API version
        let server_api = ServerApi::builder().version(ServerApiVersion::V1).build();
        client_options.server_api = Some(server_api);
        // Customize connection pooling settings
        client_options.max_pool_size = Some(200); // Maximum number of connections in the pool
        client_options.min_pool_size = Some(10);  // Minimum number of connections in the pool
        client_options.connect_timeout = Some(std::time::Duration::from_secs(10)); // Connection timeout

        let client = Client::with_options(client_options).expect("Failed to initialize client");
        let db_name = env::var("MONGODB_DB").expect("MONGODB_DB must be set");
        let db = client.database(&db_name);
        MongoRepo { db }
    }

    // Organization CRUD operations
    pub async fn create_organization(
        &self,
        org: Organization,
    ) -> Result<(), mongodb::error::Error> {
        let collection = self.db.collection::<Organization>("organizations");
        collection.insert_one(org, None).await?;
        Ok(())
    }
    // Application CRUD operations
    pub async fn create_application(&self, app: Application) -> Result<(), mongodb::error::Error> {
        let collection = self.db.collection::<Application>("applications");
        collection.insert_one(app, None).await?;
        Ok(())
    }
    pub async fn get_organization_by_cd_id_and_secret(
        &self,
        cd_id: &str,
        cd_secret: &str,
    ) -> Result<Option<Organization>, mongodb::error::Error> {
        let collection = self.db.collection::<Organization>("organizations");

        // Clean the incoming credentials
        let clean_cd_id = cd_id.trim().trim_matches('"');
        let clean_cd_secret = cd_secret.trim().trim_matches('"');
        println!("CD-ID: {}, CD-Secret: {}", clean_cd_id, clean_cd_secret);

        log::debug!(
            "Attempting to find organization with CD-ID: {} and CD-Secret: {}",
            clean_cd_id,
            clean_cd_secret
        );

        // Use a more flexible query with $regex for exact matching
        let filter = doc! {
            "cd_id": clean_cd_id.to_string(),
            "cd_secret": clean_cd_secret.to_string()
        };

        log::debug!("Query filter: {:?}", filter);
        println!("Query filter: {:?}", filter);
        let result = collection.find_one(filter, None).await?;

        if let Some(ref org) = result {
            log::info!("Found organization: {}", org.org_name);
            log::debug!(
                "Stored CD-ID: {}, CD-Secret: {}",
                org.cd_id.trim_matches('"'),
                org.cd_secret.trim_matches('"')
            );
        } else {
            log::warn!("No organization found for the provided credentials");
        }

        Ok(result)
    }

    pub async fn get_application_by_id(
        &self,
        app_id: ObjectId,
    ) -> Result<Option<Application>, mongodb::error::Error> {
        let collection = self.db.collection::<Application>("applications");
        let filter = doc! { "_id": app_id };

        match collection.find_one(filter, None).await {
            Ok(Some(app)) => {
                log::debug!("Found application with ID: {}", app_id);
                Ok(Some(app))
            }
            Ok(None) => {
                log::warn!("No application found for ID: {}", app_id);
                Ok(None)
            }
            Err(e) => {
                log::error!("Database error while looking up application: {}", e);
                Err(e)
            }
        }
    }
}



=== Content of ./src/db/pool.rs ===



=== Content of ./src/routes/health.rs ===
use actix_web::{web, HttpResponse, Responder};

pub fn init_routes(cfg: &mut web::ServiceConfig) {
    cfg.route("/health", actix_web::web::get().to(health_check));
}

async fn health_check() -> impl Responder {
    HttpResponse::Ok().json(serde_json::json!({"status": "healthy"}))
}



=== Content of ./src/routes/applications.rs ===
use crate::handlers::application_handler;
use actix_web::web;

pub fn init_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/applications")
            .route("", web::post().to(application_handler::create_application))
            .route("", web::get().to(application_handler::get_applications))
            .route("/{application_id}", web::delete().to(application_handler::delete_application)), // Added delete route
    );
}



=== Content of ./src/routes/mod.rs ===
use actix_web::web;

mod applications;
mod health;
mod logs;
mod organizations;
mod websocket;

pub fn init(cfg: &mut web::ServiceConfig) {
    logs::init_routes(cfg);
    health::init_routes(cfg);
    organizations::init_routes(cfg);
    applications::init_routes(cfg);
    websocket::init_routes(cfg);
}



=== Content of ./src/routes/websocket.rs ===
use crate::handlers::websocket_handler::websocket_handler;
use actix_web::web;

pub fn init_routes(cfg: &mut web::ServiceConfig) {
    cfg.route("/ws", web::get().to(websocket_handler));
}



=== Content of ./src/routes/organizations.rs ===
use crate::handlers::organization_handler;
use actix_web::web;

pub fn init_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/organizations")
            .route(
                "",
                web::post().to(organization_handler::create_organization),
            )
            .route(
                "",
                web::get().to(organization_handler::get_organization_details),
            ), // Add other routes like update, delete
    );
}



=== Content of ./src/routes/logs.rs ===
use crate::handlers::log_handler;
use actix_web::web;

pub fn init_routes(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/logs")
            .route("", web::get().to(log_handler::get_all_logs)) // Get all logs
            .route("/{log_id}", web::get().to(log_handler::get_log_by_id)) // Get a log by ID
            .route("", web::post().to(log_handler::save_log)) // Save a new log
            .route("/{log_id}/rag-inference", web::put().to(log_handler::update_rag_inference)), // Update RAG inference
    );
}



=== Content of ./src/handlers/websocket_handler.rs ===
use actix_web::{HttpRequest, HttpResponse, web};
use actix_web_actors::ws;
use crate::websocket::connection::WebSocketActor;
use crate::websocket::server::WebSocketServer;
use crate::db::MongoRepo;

pub async fn websocket_handler(
    req: HttpRequest,
    stream: web::Payload,
    data: web::Data<MongoRepo>,
    websocket_server: web::Data<WebSocketServer>,
) -> HttpResponse {
    let cd_id = req.headers().get("CD-ID").and_then(|h| h.to_str().ok());
    let cd_secret = req.headers().get("CD-Secret").and_then(|h| h.to_str().ok());

    if cd_id.is_none() || cd_secret.is_none() {
        return HttpResponse::BadRequest().json(serde_json::json!({
            "error": "Missing CD-ID or CD-Secret headers"
        }));
    }

    let cd_id = cd_id.unwrap();
    let cd_secret = cd_secret.unwrap();

    // Authenticate organization using CD-ID and CD-Secret
    let org = match data.get_organization_by_cd_id_and_secret(cd_id, cd_secret).await {
        Ok(Some(org)) => org,
        Ok(None) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-Secret"
            }));
        },
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to authenticate organization"
            }));
        }
    };

    // Associate WebSocket with the organization instead of an application
    let ws = WebSocketActor::new(org.id.unwrap());

    match ws::WsResponseBuilder::new(ws, &req, stream).start_with_addr() {
        Ok((addr, response)) => {
            websocket_server.add_connection(org.id.unwrap(), addr).await;
            response
        }
        Err(e) => {
            log::error!("Failed to start WebSocket: {:?}", e);
            HttpResponse::InternalServerError().finish()
        }
    }
}



=== Content of ./src/handlers/organization_handler.rs ===
use crate::db::MongoRepo;
use crate::models::organization::Organization;
use actix_web::{web, HttpResponse, Responder,HttpRequest};
use mongodb::bson::oid::ObjectId;
use mongodb::bson::doc;

pub async fn create_organization(
    payload: web::Json<Organization>,
    data: web::Data<MongoRepo>,
) -> impl Responder {
    let mut org = payload.into_inner();
    org.id = Some(ObjectId::new());
    match data.create_organization(org).await {
        Ok(_) => HttpResponse::Ok().json(serde_json::json!({"message": "Organization created"})),
        Err(e) => HttpResponse::InternalServerError().body(e.to_string()),
    }
}


pub async fn get_organization_details(
    req: HttpRequest,
    data: web::Data<MongoRepo>,
) -> impl Responder {
    // Extract CD-ID and CD-SECRET headers
    let cd_id = req
        .headers()
        .get("CD-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let cd_secret = req
        .headers()
        .get("CD-SECRET")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    // Find organization by CD-ID and CD-SECRET
    let collection = data.db.collection::<mongodb::bson::Document>("organizations");
    let filter = doc! { "cd_id": cd_id, "cd_secret": cd_secret };

    match collection.find_one(filter, None).await {
        Ok(Some(org)) => {
            let id = org.get_object_id("_id").ok();
            let org_name = org.get_str("org_name").ok();
            if let (Some(id), Some(org_name)) = (id, org_name) {
                HttpResponse::Ok().json(serde_json::json!({
                    "id": id.to_hex(),
                    "org_name": org_name,
                }))
            } else {
                HttpResponse::InternalServerError().json(serde_json::json!({
                    "error": "Incomplete organization data",
                }))
            }
        }
        Ok(None) => HttpResponse::Unauthorized().json(serde_json::json!({
            "error": "Invalid CD-ID or CD-SECRET",
        })),
        Err(_) => HttpResponse::InternalServerError().json(serde_json::json!({
            "error": "Failed to fetch organization details",
        })),
    }
}



=== Content of ./src/handlers/mod.rs ===
pub mod application_handler;
pub mod log_handler;
pub mod organization_handler;
pub mod websocket_handler;



=== Content of ./src/handlers/log_handler.rs ===
use crate::db::MongoRepo;
use crate::models::log::LogPayload;
use crate::services::log_service;
use crate::services::websocket_queue::WebSocketQueue;
use crate::websocket::server::WebSocketServer;
use actix_web::{web, HttpRequest, HttpResponse, Responder};
use serde_json::Value;
use log::{error, info};
use mongodb::bson;

use mongodb::bson::{doc, oid::ObjectId};
use mongodb::options::FindOptions;
use futures_util::stream::TryStreamExt; 


pub async fn save_log(
    req: HttpRequest,
    payload: web::Json<LogPayload>,
    data: web::Data<MongoRepo>,
    websocket_server: web::Data<WebSocketServer>,
    websocket_queue: web::Data<WebSocketQueue>,
) -> impl Responder {
    let cd_id = match req.headers().get("CD-ID") {
        Some(value) => match value.to_str() {
            Ok(v) => {
                log::debug!("Received CD-ID: {}", v);
                v
            }
            Err(_) => {
                log::error!("Invalid CD-ID header encoding");
                return HttpResponse::BadRequest().json(serde_json::json!({
                    "error": "Invalid CD-ID header encoding"
                }));
            }
        },
        None => {
            log::error!("Missing CD-ID header");
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Missing CD-ID header"
            }));
        }
    };

    let cd_secret = match req.headers().get("CD-Secret") {
        Some(value) => match value.to_str() {
            Ok(v) => {
                log::debug!("Received CD-Secret: {}", v);
                v
            }
            Err(_) => {
                log::error!("Invalid CD-Secret header encoding");
                return HttpResponse::BadRequest().json(serde_json::json!({
                    "error": "Invalid CD-Secret header encoding"
                }));
            }
        },
        None => {
            log::error!("Missing CD-Secret header");
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Missing CD-Secret header"
            }));
        }
    };

    let application_id = match req.headers().get("Application-ID") {
        Some(value) => match value.to_str() {
            Ok(v) => v,
            Err(_) => {
                error!("Invalid Application-ID header");
                return HttpResponse::BadRequest().body("Invalid Application-ID header");
            }
        },
        None => {
            error!("Missing Application-ID header");
            return HttpResponse::BadRequest().body("Missing Application-ID header");
        }
    };

    let org = match data
        .get_organization_by_cd_id_and_secret(cd_id, cd_secret)
        .await
    {
        Ok(Some(org)) => {
            log::info!("Successfully authenticated organization: {}", org.org_name);
            org
        }
        Ok(None) => {
            log::warn!("Authentication failed for CD-ID: {}", cd_id);
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-Secret"
            }));
        }
        Err(e) => {
            log::error!("Database error during organization lookup: {}", e);
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Internal server error during authentication"
            }));
        }
    };

    let app_id = match ObjectId::parse_str(application_id) {
        Ok(id) => id,
        Err(_) => {
            error!("Invalid Application-ID format");
            return HttpResponse::BadRequest().body("Invalid Application-ID format");
        }
    };

    let app = match data.get_application_by_id(app_id).await {
        Ok(Some(app)) => app,
        Ok(None) => {
            error!("Application not found");
            return HttpResponse::NotFound().body("Application not found");
        }
        Err(e) => {
            error!("Database error: {}", e);
            return HttpResponse::InternalServerError().body("Database error");
        }
    };

    // Ensure the application belongs to the organization
    if app.organization_id != Some(org.id.unwrap()) {
        error!("Application does not belong to the organization");
        return HttpResponse::Unauthorized()
            .body("Application does not belong to the organization");
    }
    // Process the log
    let mut log = payload.into_inner();
    log.organization_id = Some(org.id.unwrap());
    log.application_id = Some(app.id.unwrap());

    match log_service::process_log(
        log,
        data.clone(),
        websocket_server.clone(),
        websocket_queue.clone(),
    )
    .await
    {
        Ok(_) => HttpResponse::Ok().json(serde_json::json!({"message": "Log saved"})),
        Err(e) => HttpResponse::InternalServerError().body(e.to_string()),
    }
}




pub async fn get_log_by_id(
    req: HttpRequest,
    path: web::Path<String>,
    data: web::Data<MongoRepo>,
) -> impl Responder {
    // Extract headers for authentication
    let cd_id = req
        .headers()
        .get("CD-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let cd_secret = req
        .headers()
        .get("CD-Secret")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let app_id = req
        .headers()
        .get("Application-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    // Validate ObjectId from URL
    let log_id = match ObjectId::parse_str(path.into_inner()) {
        Ok(id) => id,
        Err(_) => {
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Invalid log ID format"
            }));
        }
    };

    // Authenticate organization using CD-ID and CD-Secret
    let org = match data.get_organization_by_cd_id_and_secret(cd_id, cd_secret).await {
        Ok(Some(org)) => org,
        Ok(None) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-Secret"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to authenticate organization"
            }));
        }
    };

    // Validate Application-ID
    let app_id = match ObjectId::parse_str(app_id) {
        Ok(id) => id,
        Err(_) => {
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Invalid Application-ID format"
            }));
        }
    };

    // Ensure application belongs to the authenticated organization
    let app = match data.get_application_by_id(app_id).await {
        Ok(Some(app)) if app.organization_id == Some(org.id.unwrap()) => app,
        Ok(_) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Application does not belong to the organization"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to validate application"
            }));
        }
    };

    // Fetch log from database
    let collection = data.db.collection::<LogPayload>("logs");
    match collection.find_one(doc! { "_id": log_id, "application_id": app.id.unwrap() }, None).await
    {
        Ok(Some(log)) => HttpResponse::Ok().json(log),
        Ok(None) => HttpResponse::NotFound().json(serde_json::json!({
            "error": "Log not found"
        })),
        Err(_) => HttpResponse::InternalServerError().json(serde_json::json!({
            "error": "Failed to retrieve log"
        })),
    }
}


/// Fetch all logs for a specific organization and application.
pub async fn get_all_logs(
    req: HttpRequest,
    data: web::Data<MongoRepo>,
) -> impl Responder {
    // Extract headers
    let cd_id = req
        .headers()
        .get("CD-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let cd_secret = req
        .headers()
        .get("CD-Secret")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let app_id = req
        .headers()
        .get("Application-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    // Authenticate organization using CD-ID and CD-Secret
    let org = match data.get_organization_by_cd_id_and_secret(cd_id, cd_secret).await {
        Ok(Some(org)) => org,
        Ok(None) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-Secret"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to authenticate organization"
            }));
        }
    };

    // Validate Application-ID
    let app_id = match mongodb::bson::oid::ObjectId::parse_str(app_id) {
        Ok(id) => id,
        Err(_) => {
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Invalid Application-ID format"
            }));
        }
    };

    let app = match data.get_application_by_id(app_id).await {
        Ok(Some(app)) if app.organization_id == Some(org.id.unwrap()) => app,
        Ok(_) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Application does not belong to the organization"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to validate application"
            }));
        }
    };

    // Fetch logs from the database
    let collection = data.db.collection::<LogPayload>("logs");
    let filter = doc! { "application_id": app.id.unwrap() };

    let find_options = FindOptions::builder()
        .sort(doc! { "_id": -1 }) // Optional: Sort by descending order of insertion
        .build();

    match collection.find(filter, find_options).await {
        Ok(mut cursor) => {
            let mut logs = Vec::new();
            while let Some(log) = cursor.try_next().await.unwrap_or(None) {
                logs.push(log);
            }
            HttpResponse::Ok().json(logs)
        }
        Err(_) => HttpResponse::InternalServerError().json(serde_json::json!({
            "error": "Failed to retrieve logs"
        })),
    }
}


/// Update the `rag_inference` field of a specific log.
pub async fn update_rag_inference(
    req: HttpRequest,
    path: web::Path<String>,
    data: web::Data<MongoRepo>,
    payload: web::Json<Value>, // The `rag_inference` data
) -> impl Responder {
    // Extract headers for authentication
    let cd_id = req
        .headers()
        .get("CD-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let cd_secret = req
        .headers()
        .get("CD-Secret")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let app_id = req
        .headers()
        .get("Application-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    // Parse `log_id` from the URL
    let log_id = match ObjectId::parse_str(path.into_inner()) {
        Ok(id) => id,
        Err(_) => {
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Invalid log ID format"
            }));
        }
    };

    // Authenticate the organization using `CD-ID` and `CD-Secret`
    let org = match data.get_organization_by_cd_id_and_secret(cd_id, cd_secret).await {
        Ok(Some(org)) => org,
        Ok(None) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-Secret"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to authenticate organization"
            }));
        }
    };

    // Validate the `Application-ID`
    let app_id = match ObjectId::parse_str(app_id) {
        Ok(id) => id,
        Err(_) => {
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Invalid Application-ID format"
            }));
        }
    };

    let app = match data.get_application_by_id(app_id).await {
        Ok(Some(app)) if app.organization_id == Some(org.id.unwrap())=> app,
        Ok(_) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Application does not belong to the organization"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to validate application"
            }));
        }
    };

    // Update the `rag_inference` field in the log
    let collection = data.db.collection::<LogPayload>("logs");
    let filter = doc! {
        "_id": log_id,
        "application_id": app.id.unwrap(),
    };
    let update = doc! {
        "$set": {
            "rag_inference": bson::to_bson(&payload.into_inner()).unwrap_or(bson::Bson::Null),
        }
    };

    match collection.update_one(filter, update, None).await {
        Ok(update_result) if update_result.matched_count > 0 => {
            info!("Updated `rag_inference` for log ID: {}", log_id);
            HttpResponse::Ok().json(serde_json::json!({
                "message": "RAG inference updated successfully"
            }))
        }
        Ok(_) => HttpResponse::NotFound().json(serde_json::json!({
            "error": "Log not found"
        })),
        Err(_) => HttpResponse::InternalServerError().json(serde_json::json!({
            "error": "Failed to update RAG inference"
        })),
    }
}


=== Content of ./src/handlers/application_handler.rs ===
use crate::db::MongoRepo;
use crate::models::application::{Application, DeleteApplicationPayload};
use actix_web::{web, HttpResponse, Responder};
use mongodb::bson::oid::ObjectId;
use actix_web::{ HttpRequest};
use mongodb::bson::doc;
use futures_util::stream::TryStreamExt;

pub async fn create_application(
    req: HttpRequest,
    payload: web::Json<Application>,
    data: web::Data<MongoRepo>,
) -> impl Responder {
    // Extract CD-ID and CD-SECRET headers
    let cd_id = req
        .headers()
        .get("CD-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let cd_secret = req
        .headers()
        .get("CD-SECRET")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    // Authenticate organization using CD-ID and CD-SECRET
    let org = match data.get_organization_by_cd_id_and_secret(cd_id, cd_secret).await {
        Ok(Some(org)) => org,
        Ok(None) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-SECRET"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to authenticate organization"
            }));
        }
    };

    // Prepare the application
    let mut app = payload.into_inner();
    let app_id = ObjectId::new(); // Generate a new ObjectId
    app.id = Some(app_id.clone());
    app.organization_id = Some(org.id.unwrap()); // Set the authenticated organization's ID

    // Save the application to the database
    match data.create_application(app).await {
        Ok(_) => HttpResponse::Ok().json(serde_json::json!({
            "message": "Application created",
            "application_id": app_id.to_string() // Include the created application ID
        })),
        Err(e) => HttpResponse::InternalServerError().body(e.to_string()),
    }
}

pub async fn get_applications(
    req: HttpRequest,
    data: web::Data<MongoRepo>,
) -> impl Responder {
    // Extract CD-ID and CD-Secret headers
    let cd_id = req
        .headers()
        .get("CD-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let cd_secret = req
        .headers()
        .get("CD-Secret")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    // Authenticate organization using CD-ID and CD-Secret
    let org = match data.get_organization_by_cd_id_and_secret(cd_id, cd_secret).await {
        Ok(Some(org)) => org,
        Ok(None) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-Secret"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to authenticate organization"
            }));
        }
    };

    // Fetch all applications for the authenticated organization
    let collection = data.db.collection::<Application>("applications");
    let filter = doc! { "organization_id": org.id.unwrap() };

    match collection.find(filter, None).await {
        Ok(mut cursor) => {
            let mut applications = Vec::new();
            while let Some(app) = cursor.try_next().await.unwrap_or(None) {
                applications.push(app);
            }
            HttpResponse::Ok().json(applications)
        }
        Err(_) => HttpResponse::InternalServerError().json(serde_json::json!({
            "error": "Failed to fetch applications"
        })),
    }
}

pub async fn delete_application(
    req: HttpRequest,
    path: web::Path<String>, // Extract application ID from the URL
    data: web::Data<MongoRepo>,
) -> impl Responder {
    // Extract CD-ID and CD-SECRET headers
    let cd_id = req
        .headers()
        .get("CD-ID")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();
    let cd_secret = req
        .headers()
        .get("CD-SECRET")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default();

    // Authenticate organization using CD-ID and CD-SECRET
    let org = match data.get_organization_by_cd_id_and_secret(cd_id, cd_secret).await {
        Ok(Some(org)) => org,
        Ok(None) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid CD-ID or CD-SECRET"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to authenticate organization"
            }));
        }
    };

    // Validate and parse application_id from the URL
    let application_id = match ObjectId::parse_str(&path.into_inner()) {
        Ok(id) => id,
        Err(_) => {
            return HttpResponse::BadRequest().json(serde_json::json!({
                "error": "Invalid application ID format"
            }));
        }
    };

    // Ensure the application belongs to the authenticated organization
    let app = match data.get_application_by_id(application_id).await {
        Ok(Some(app)) if app.organization_id == Some(org.id.unwrap()) => app,
        Ok(_) => {
            return HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Application does not belong to the authenticated organization"
            }));
        }
        Err(_) => {
            return HttpResponse::InternalServerError().json(serde_json::json!({
                "error": "Failed to validate application"
            }));
        }
    };

    // Delete the application
    let collection = data.db.collection::<Application>("applications");
    match collection.delete_one(doc! { "_id": app.id.unwrap() }, None).await {
        Ok(delete_result) if delete_result.deleted_count > 0 => {
            HttpResponse::Ok().json(serde_json::json!({
                "message": "Application deleted successfully"
            }))
        }
        Ok(_) => HttpResponse::NotFound().json(serde_json::json!({
            "error": "Application not found"
        })),
        Err(_) => HttpResponse::InternalServerError().json(serde_json::json!({
            "error": "Failed to delete application"
        })),
    }
}



=== Content of ./src/services/mod.rs ===
pub mod log_service;
pub mod websocket_queue;



=== Content of ./src/services/websocket_queue.rs ===
use actix::Addr;
use log::{info, warn};
use mongodb::bson::oid::ObjectId;
use std::collections::VecDeque;
use std::sync::Arc;
use tokio::sync::RwLock;

/// Represents a log delivery retry queue entry.
#[derive(Debug, Clone)]
pub struct RetryQueueEntry {
    pub organization_id: ObjectId,
    pub application_id: ObjectId,
    pub log_id: ObjectId,
}

/// A thread-safe retry queue for undelivered logs.
#[derive(Clone)]
pub struct WebSocketQueue {
    queue: Arc<RwLock<VecDeque<RetryQueueEntry>>>,
}

impl WebSocketQueue {
    /// Creates a new WebSocketQueue instance.
    pub fn new() -> Self {
        Self {
            queue: Arc::new(RwLock::new(VecDeque::new())),
        }
    }

    /// Adds a new log entry to the retry queue.
    pub async fn enqueue(&self, entry: RetryQueueEntry) {
        let mut queue = self.queue.write().await;
        queue.push_back(entry);
        info!("Log added to retry queue. Queue size: {}", queue.len());
        println!("Log added to retry queue. Queue size: {}", queue.len());
    }

    /// Retrieves and removes the oldest log entry from the retry queue, if available.
    pub async fn dequeue(&self) -> Option<RetryQueueEntry> {
        let mut queue = self.queue.write().await;
        let entry = queue.pop_front();
        if let Some(ref e) = entry {
            info!(
                "Dequeued log for Org ID: {}, App ID: {}, Log ID: {}",
                e.organization_id, e.application_id, e.log_id
            );
            println!(
                "Dequeued log for Org ID: {}, App ID: {}, Log ID: {}",
                e.organization_id, e.application_id, e.log_id
            );
        }
        entry
    }

    /// Returns the current size of the retry queue.
    pub async fn size(&self) -> usize {
        let queue = self.queue.read().await;
        queue.len()
    }

    /// Attempts to process the retry queue, delivering logs to active WebSocket connections.
    /// If delivery fails, the log is re-added to the queue for another retry.
    pub async fn process_queue<F>(&self, get_connection: F)
    where
        F: Fn(ObjectId, ObjectId) -> Option<Addr<crate::websocket::connection::WebSocketActor>>,
    {
        loop {
            let entry = self.dequeue().await;

            if let Some(log_entry) = entry {
                if let Some(conn) =
                    get_connection(log_entry.organization_id, log_entry.application_id)
                {
                    info!(
                        "Attempting to deliver log ID: {} to Org ID: {}, App ID: {}",
                        log_entry.log_id, log_entry.organization_id, log_entry.application_id
                    );
                    println!("Attempting to deliver log ID: {} to Org ID: {}, App ID: {}", log_entry.log_id, log_entry.organization_id, log_entry.application_id);

                    conn.do_send(crate::websocket::connection::SendLogId {
                        log_id: log_entry.log_id,app_id:log_entry.application_id
                    });
                } else {
                    warn!(
                        "No WebSocket connection found for Org ID: {}, App ID: {}. Re-queuing log ID: {}.",
                        log_entry.organization_id, log_entry.application_id, log_entry.log_id
                    );
                    println!("No WebSocket connection found for Org ID: {}, App ID: {}. Re-queuing log ID: {}.", log_entry.organization_id, log_entry.application_id, log_entry.log_id);

                    self.enqueue(log_entry).await;
                }
            }

            // Optional: Adjust this delay based on your requirements.
            tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
        }
    }
}



=== Content of ./src/services/log_service.rs ===
use crate::db::MongoRepo; // Fixes missing `MongoRepo`
use crate::models::log::LogPayload; // Fixes missing `LogPayload`
use crate::services::websocket_queue::WebSocketQueue;
use chrono::Utc;
use crate::websocket::server::WebSocketServer; // Fixes unresolved `WebSocketServer`
use actix_web::web; // Fixes `use of undeclared crate or module 'web'` // Fixes unresolved `websocket_queue`

pub async fn process_log(
    mut log: LogPayload,
    data: web::Data<MongoRepo>,
    websocket_server: web::Data<WebSocketServer>,
    websocket_queue: web::Data<WebSocketQueue>,
) -> Result<(), String> {
    log::info!("Processing log: {:?}", log);
    // Set created_at and updated_at if not already provided
    let now = Utc::now();
    log.created_at = log.created_at.or(Some(now));
    log.updated_at = log.updated_at.or(Some(now));

    let collection = data.db.collection::<LogPayload>("logs");
    let inserted_log = collection
        .insert_one(&log, None)
        .await
        .map_err(|e| e.to_string())?;
    let log_id = inserted_log
        .inserted_id
        .as_object_id()
        .ok_or("Failed to retrieve inserted log ID")?;

    log::info!("Log inserted with ID: {}", log_id);
    println!("Log inserted with ID: {}", log_id);

    // Attempt to deliver the log via WebSocket
    let org_id = log.organization_id.ok_or("Organization ID missing")?;
    let app_id = log.application_id.ok_or("Application ID missing")?;

    if !websocket_server
        .push_log_id(org_id.clone(), app_id.clone(), log_id.clone())
        .await
    {
        // // If no connection is available, add to the retry queue
        // let retry_entry = RetryQueueEntry {
        //     organization_id: org_id,
        //     application_id: app_id,
        //     log_id,
        // };
        // websocket_queue.enqueue(retry_entry).await;
    }

    Ok(())
}


